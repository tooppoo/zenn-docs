---
title: "「わかりやすさ」「説得力」は有害（Harmful）である"
emoji: "🤔"
type: "idea" # tech: 技術記事 / idea: アイデア
published: false
---

## はじめに

**「わかりやすさ」「説得力」は有害（Harmful）である**[^1]

[^1]: ダイクストラの論文「Go To Statement Considered Harmful」を文字った

最初に告白しておくと、このタイトルは耳目を集めるための挑発である。
一般に「良い」とされている概念に対して強い否定の言葉を用いることで、注意を引くため狙いだ。

だが、本稿の狙いは逆張りそのものではない。「わかりやすさ」「説得力」といった美辞麗句の下に、不確実さや曖昧さがどのように隠されているのか、その構造を検討することである。

本稿では、そうした態度が具体的にどのような問題を生むのかを確認したうえで、それに対する代案として「**透明性の倫理**」という考え方を提示する。

## なぜ「わかりやすさ」「説得力」が害を生むのか

少なくとも私の見てきた日本語圏のソフトウェア技術記事では、「わかりやすい説明」がしばしば上位価値として扱われてきた。  「説得力のある説明」もまた、テキストの「価値」を高め、より多くの人に主張内容を受け入れてもらうために重要なものとみなされてきた。

書籍・ブログ・入門記事の多くが、「わかりやすく」「説得力がある」テキストを書くことで、「読者が理解した“気”になれること」を目標としている。実際、ネットを見ても「わかりやすく説明する方法」「わかりやすい説明にする方法」などを解説する記事が散見される。

しかし、この「わかりやすさ」「説得力」が、構造的に誤解を生む場面がある。

### 観点1. 比喩は概念を削り、滑らかさと引き換えに本質を歪める

わかりやすい説明として頻繁に用いられる比喩は、 **概念の一部を切り落とし、ときには置き換える** ことで成立する。そのため、比喩がうまく聞こえるほど、本来の概念から離れていく危険がある。

ここでは代表例として **「クラスは設計図、インスタンスは製品」** という比喩を取り上げたい。これは入門記事の定番比喩だが、オブジェクト指向における実際の関係・位置づけとは乖離している。以下では、その乖離を3つの点から整理する。

#### 問題1. クラスは固定された静的存在ではない

「設計図」は通常、変更されない前提で語られる。  
しかし現実のオブジェクト指向プログラミング言語（以下、OOPL）の中には、クラスは **動的に再定義可能** であり、メタクラスを通じて構造や振る舞いを後から変更できるものも存在する。

例えばSmalltalk 系のOOPL、あるいはRubyでは、クラス自身も“オブジェクト”であり、動的操作の対象だ[^2][^3]。その他、JavaScriptにおけるclassもその実態は「特殊な関数」オブジェクトであるから、やはり動的操作が可能である[^4]。

[^2]: https://www.gnu.org/software/smalltalk/manual/html_node/Why-is-_0023new-there_003f_0021_003f.html 2025-12-08 19:57閲覧<br>> *The truth starts showing to their eyes about that sentence that everybody says but few people understand: “classes are objects”.'*
[^3]: https://docs.ruby-lang.org/ja/latest/class/Class.html 2025-12-08 19:59閲覧
[^4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes 2025-12-08 20:06閲覧<br>> *'Classes are in fact "special functions", and just as you can define function expressions and function declarations, a class can be defined in two ways: a class expression or a class declaration.'*

クラスを「設計図」として例えた時、そこではクラスそれ自体の動的性質（メタプログラミングや、実行時再定義の可能性など）は切り捨てられて語られている。

#### 問題2. インスタンスは受動的な“製品”ではない

製品は通常、能動的に振る舞いを持たない物体である。  
しかしオブジェクト指向におけるインスタンスは **メッセージに応答し、主体として振る舞う**というのが本義である。

“製品”という比喩を用いている場面では、オブジェクトの主体性・自律性は無視されている。

#### 問題3. クラスとインスタンスは一方向の固定関係ではない

現実のオブジェクト指向では、言語にもよるが、継承・プロトタイプチェーン・ミックスイン・トレイトなど多様な構造が存在する。  
“設計図 → 製品”のような一方向・1対1の関係では説明できない。

特にRubyやSmalltalkのような「クラスもまた別のクラス（メタクラス）のインスタンスである」というある種の再帰的な構造は、設計図と製品という静的・一方向の関係ではほとんど捉えられない。
---

一見わかりやすい比喩ほど、本質を切除し、理解を固定化し、思考の幅を狭める危険がある。比喩は「説明したい観点に着目して語る」という性質上、どうしてもこうした情報の切り捨てが発生するからだ。
しかし「わかりやすい」ことを上位の価値と位置づけてしまうと、こうした危険を無視ないし矮小化することを正当化可能となってしまう。

### 観点2. 説得力は、内容の正しさとは無関係に操作できる

説得力とは、内容の正しさではなく **読者が受け取る印象の強さ** である。「説得力を出す」とは「印象操作」としての側面を少なからず持つ。そのため、論理が粗かったり根拠が薄かったりしても、「説得力がある文章」は書けてしまう。

たとえば次の文章を考える。

```text
関数型言語では副作用は禁止されている。
なぜなら、副作用は状態を乱し、バグの原因になるからだ。
```

関数型プログラミング言語に明るくない人にとっては、説得力を持った文章として映るだろう。
しかし、実際には以下の問題がある。

#### 問題1：前提が誤っている  

関数型言語の多くは「副作用を禁止」していない。  
副作用を **分離** したり、**制御** したり、**明示** する仕組みを持ってはいるが、これらはいずれも「禁止」とは異なる。

例えばHaskellでは入出力という副作用を`IO`モナドとして分離可能にしているが、入出力という副作用の利用を「禁止」しているわけではない[^5]。

[^5]: Miran Lipova(2012) p.160<br>> *Haskell は、副作用を持つ関数を扱うための素晴らしく賢いシステムを持っているのです。そのシステムが、プログラムの純粋（pure）な部分と、キーボードや画面とやり取りするようなすべての汚い仕事をする不純（impure）な部分とをきっちりと分離してくれます。この2つの部分が隔てられているので、外の世界とやり取りしつつも、依然としてプログラムの純粋な部分を推論したり、純粋だからこそ得られる遅延評価、堅牢性、関数合成などを利用したりできます。*

文章の“強さ”が内容の“正しさ”を保証しない典型例と言える。

#### 問題2：論理構造が曖昧でも「筋が通っているように見える」  

「Aは禁止されている。なぜならBだからだ。」  

安易に用いられがちなこの形式自体が、一見しての“確からしさ”を演出してしまう。しかし実際には、以下の問題がこの一文には混在している。

- 「副作用を禁止している」という事実誤認  
- 「副作用は状態を乱す」という一般論  
- 「ゆえに禁止」という飛躍  

それでも関数型言語に明るくない読者なら、文章のリズムだけで「なるほど」と感じやすくなってしまう。

#### 問題3：根拠の薄弱さが隠される

この文章には情報源が示されていないが、説得力は、しばしば**情報源の欠如すら隠してしまう**。これを濫用すれば、「根拠は薄弱にもかかわらず、他人の心情に訴えかける説得力あるテキスト」が作成できてしまう。

---

説得力は、論理と独立した“印象操作”である以上、それに頼った説明を行ったり、それに頼った説明を鵜呑みにするのは危険であると言って良い。

### 観点3. 情報源の不透明性が隠蔽される

「◯◯とは〜〜である。X氏が提唱した。」  

この形式の文章は、あたかも一次情報をきちんと参照しているかのような印象を与える。しかし、**実際にどの文献のどの箇所を見たのか** が示されないまま、こうした文言が用いられていることは珍しくない。

ここでは、特にドメイン駆動設計（以下、DDD）文脈で頻出する「値オブジェクト」を具体例として扱う。値オブジェクトについて、以下のような説明を考えてみる。

```txt
プリミティブ型をクラスで包み、immutableにしたオブジェクトが、値オブジェクトである。
これはMartin Fowlerによって提唱された。
```

この説明も一見してもっともらしく、近しい説明すら見かけることがある。しかし出典を実際に辿っていくと、この定義は少なくとも**不必要に狭い**か、場合によっては誤解を招く定義と言える。
#### 問題1. 「等価性」という概念が、二次情報で欠落する構造

Martin Fowlerによる著作『エンタープライズアプリケーションアーキテクチャ』（以下PoEAA）の「バリューオブジェクト」を参照してみよう。

> ID に基づいた等価性を確保していない、Money やDate Range などのシンプルな小型オブジェクト。
> (中略)
> 参照オブジェクトとバリューオブジェクトの主な相違点は、等価性の処理の方法である。(中略)バリューオブジェクトの等価性の概念はクラス内のフィールド値に基づいている。2つのDateオブジェクトで日、月、年の値が同じ場合は、等価ということになる。[^6]

[^6]: Martin Fowler(2005) p.508-509

先に提示した説明例では「等価性」という性質への言及は含まれていない。結果「出典を遡らない限り、"等価性"という中心概念にはたどり着けない」という事態に陥っている。

#### 問題2. 実装スタイルが「定義」として誤読される構造

今度は、DDDの提唱者であるEric Evansの著書『エリック・エヴァンスのドメイン駆動設計』を参照してみる。

> あるオブジェクトが、ドメインにおける記述的な側面を表現し、概念的な同一性を持たない場合、そういうオブジェクトは、値オブジェクトと呼ばれる。
> (中略)
> 値オブジェクトは、他のオブジェクトが組み合わされてできていることもある。
> (中略)
> 値オブジェクトはエンティティを参照することもできる。[^7]

[^7]: Eric Evans(2014) p.96

エヴァンス本によれば、値オブジェクトはそれ自体複数のオブジェクトで構成されることもありうるのだから、「プリミティブ型をクラスで包む」という記述は、明確に誤りあるいは余計な制約である。
ここでは「出典を遡らない限り、本来不要な制約に縛られてしまう」という事態が生じている。

#### 問題3. 推奨レベルの話が「必須条件」に格上げされる構造

Martin Fowlerのブログ"martinFowler.com"にも、Value Objectについての言及がある。

> To avoid aliasing bugs I follow a simple but important rule: **value objects should be immutable**. If I want to change my party date, I create a new object instead.
> (中略)
> While immutability is my favorite technique to avoid aliasing bugs, it's also possible to avoid them by ensuring assignments always make a copy. Some languages provide this ability, such as structs in C#.[^8]

[^8]: Value Object - martinFowler.com 2025-12-09 12:55 閲覧

Fowler自身によっても、immutableにするのはあくまでオブジェクトを共有する際の不具合を回避するための一つの手法であり[^9]、immutableにする以外の方法として、「常にコピーを生成する(it's also possible to avoid them by ensuring assignments always make a copy)」もはっきりと認められている。

[^9]: Value Objectについて整理しよう 2025-12-09 20:30 閲覧<br>> *一番重要なのは「値(Value)」という概念そのもの。それが複数の値の合成物からなる値ならばオブジェクトを定義してプロパティで等価比較する実装手段がいい、これをValue Objectと呼ぶ。だがオブジェクトを取り回す際には言語によっては無意識の共有操作に手を噛まれないようにせよ、回避策としてimmutableにするのもアリだよ。この順が重要である。*

ここでは、原典では「should」だった要素が二次情報では「must」に変化しているという、やはり出典を遡って初めて発見できる問題が隠れている。

---

ここまで、例として出した「値オブジェクトの定義」にどのような問題があるかを述べてきた。しかしながら、二次情報・三次情報ではしばしば次のような縮約が起きる。

1. 一次情報の文脈を削り、「値オブジェクトは immutable にすべき」という一文だけが切り出される  
2. さらにそれが、「プリミティブを包んだ immutable クラス」という**実装スタイルの一案**と結びつく  
3. やがて、「値オブジェクト＝プリミティブラッパ＋ immutable」が“定義”として扱われるようになる

この過程で、「等価性を値によって判断する」「オブジェクトも含めた複合体として構成可能である」「共有時の問題を回避するためのimmutable」といった本来の情報は失われてしまう。

その結果、次のような現象が起きる。

- ドメイン内のあらゆる整数や文字列を、専用クラスで機械的に包むだけの「値オブジェクト大量生産」が始まる  
- それを「原典がそう言っているから」という形で正当化しようとする  
- しかし、どのページのどの記述を根拠にしているのかは示されない  

ここでは、その意図の有無によらず、**「誰かの解釈」が「原典の主張」として権威化される** という事態が生じている。
しかし、一次情報へ辿るための手がかり（書名、ページ数）が提示されないため、読者はその解釈が妥当かどうかを自力で検証しにくい。

本来であれば、「どの資料の」「どこの箇所の」「どの記述を」どのように読んで「値オブジェクト」を理解したのかを、最低限でも示すべきである。それを省略したまま「◯◯とは〜〜であり、X氏がそう言っている」とだけ書くことは、意図的にせよ、結果的にせよ、**情報源の不透明性で読者を騙す構図**になりうる。
情報源が曖昧な説明は、「理解した“つもり”」だけを量産し、読者から「自分で確かめる手段」と「疑う権利」を奪ってしまう。

### まとめ：なぜ「わかりやすさ」「説得力」が害を生むのか

比喩は情報を丸めて滑らかにする一方で、多くの情報を暗黙的に削り捨ててしまう。
説得力は、その一見した尤もらしさによって、論理の脆弱さや根拠の薄弱さを覆い隠してしまう。
引用の欠落によって、誰かの解釈が権威を伴って広まり、しかしその原典へのアクセスは困難になってしまう。

**結果として、「理解した気分」だけが加速し、「実際の理解」は置き去りになる。**

わかりやすさと説得力は、必ずしも良い結果を招かない。むしろ、「透明性の倫理」に従わないのであれば、容易に不利益を撒き散らす。
「わかりやすさ」「説得力」が不透明性を伴うとき、それは誤解を固定化し、検証の回路を断つという点で、倫理的に許容しがたい。

## 「透明性の倫理」とは何か

本稿で「透明性の倫理」と呼ぶのは、端的に言えば次の態度である。

> **自分の限界と、自分の範囲を明示せよ。**

この一文は、以下の三つに分解できる。

1. 限界の開示
2. 範囲の開示（事実と解釈の分離）
3. 権威と主張の切断

以降では、この三つを順に見ていく。

### 1. 限界の開示

- どこまで遡れたか  
- どこで理解が途切れたか  
- どこから先が推測なのか  

理解が不十分であっても、それを明示すれば害は小さくなる。  
「どこまで調べたか」を公開すること自体が、読者への誠実な情報提供となる。

### 2. 範囲の開示（事実と解釈の分離）

資料の内容と、自分の解釈・主張を混ぜないこと。  
混ざると、資料の権威を借りて自分の立場を正当化する構造が生まれる。

引用表記や段落構成などを用いて、  
**「何が事実で、何が自分の思考か」**  
を読者に見える形で分離する必要がある。

### 3. 権威と主張の切断

一次資料の記述は「事実の提示」であり、筆者の主張を必然的に裏付けるわけではない。  
引用した瞬間に自説が強化されるわけではない。  
自分の主張は、自分の論として独立させなければならない。

## 「透明性の倫理」実践例：「単一責任原則」について

## 結び：透明性は、書き手と読み手の自由を守る

透明性の倫理は、書き手を縛るための規律ではない。  
むしろ、断言圧力や完璧主義から書き手を解放する枠組みである。

- 「ここまではわかっている」  
- 「ここから先は推測だ」  
- 「この部分は一次資料をまだ追えていない」

そう書いてよい。  
そう書くことで、読者はどこを信じ、どこを疑い、どこを自分で調べるべきか判断できる。

わかりやすさと説得力、いずれもそれ自体が悪ではない。  
しかし、透明性を欠いた説明は、たとえ滑らかであっても理解の役に立たない。

**理解とは、境界線と限界が明示された場所にこそ生まれる。**

## 参考資料

- "Go To Statement Considered Harmful"
  - <https://dl.acm.org/doi/10.1145/362929.362947> 2025-12-08 15:15閲覧
- GNU Smalltalk User’s Guide
  - <https://www.gnu.org/software/smalltalk/manual/html_node/Why-is-_0023new-there_003f_0021_003f.html>
- Ruby3.4 リファレンスマニュアル
  - <https://docs.ruby-lang.org/ja/latest/class/Class.html>
- MDN
  - <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes>
- Eric Evans(2011)『エリック・エヴァンスのドメイン駆動設計』翔泳社 今関剛 監訳, 和智右桂・牧野祐子 訳
- Martin Fowler(2005)『エンタープライズアプリケーションアーキテクチャ』翔泳社　長瀬嘉秀 監訳, 株式会社テクノロジックアート 訳
- Value Object - martinFowler.com
  - <https://martinfowler.com/bliki/ValueObject.html>
- Value Objectについて整理しよう
  - <https://kumagi.hatenablog.com/entry/value-object>
- 値オブジェクトへの誤解が生まれる一つのストーリー - 文脈と定義を大事にする
  - <https://zenn.dev/339/articles/554d9f1e8cc645>
