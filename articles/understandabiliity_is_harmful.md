---
title: "「わかりやすさ」「説得力」は有害（Harmful）である"
emoji: "🤔"
type: "idea" # tech: 技術記事 / idea: アイデア
published: false
---

## はじめに

**「わかりやすさ」「説得力」は有害（Harmful）である**[^1]

[^1]: ダイクストラの論文「Go To Statement Considered Harmful」を文字った

最初に告白しておくと、このタイトルは耳目を集めるための挑発である。
一般に「良い」とされている概念に対して強い否定の言葉を用いることで、耳目を引くために用いた語法だ。

とはいえ、本稿は単なる逆張りではない。自分なりの問題意識からこれらの概念に依拠するものに、より正確には、「わかりやすい」「説得力のある」記事やテキストを書こうとするある種の態度にたいして、批判的吟味を試みることが本稿の目的だ。

本稿で批判しようとしているのは「わかりやすさ」「説得力」そのものではない。問題とするのは、不確実さや理解の曖昧さを抱えたまま、それを「わかりやすさ」「説得力」といった美辞麗句の下に隠してしまう態度である。

本稿では、この態度の構造的問題を確認したうえで、それに対する代案として「**透明性の倫理**」という考え方を提示する。

## なぜ「わかりやすさ」「説得力」が害を生むのか

日本語圏のソフトウェア技術記事では、「わかりやすい説明」がしばしば上位価値として扱われてきた。  「説得力のある説明」もまた、テキストの「価値」を高め、より多くの人に主張内容を受け入れてもらうために重要なものとみなされてきた。

書籍・ブログ・入門記事の多くが、「わかりやすく」「説得力がある」テキストを書くことで、「読者が理解した“気”になれること」を目標としている。実際、ネットを見ても「わかりやすく説明する方法」「わかりやすい説明にする方法」などを解説する記事が散見される。

しかし、この「わかりやすさ」「説得力」が、構造的に誤解を生む場面がある。

### 観点1. 比喩は概念を削り、滑らかさと引き換えに本質を歪める

わかりやすい説明として頻繁に用いられる比喩は、 **概念の一部を切り落とし、ときには置き換える** ことで成立する。そのため、比喩がうまく聞こえるほど、本来の概念から離れていく危険がある。

ここでは代表例として **「クラスは設計図、インスタンスは製品」** という比喩を取り上げたい。これは入門記事の定番比喩だが、オブジェクト指向における実際の関係・位置づけとは乖離している。以下では、乖離している観点を3つ上げている。

#### 問題1. クラスは固定された静的存在ではない

「設計図」は通常、変更されない前提で語られる。  
しかし現実のオブジェクト指向プログラミング言語（以下、OOPL）では、クラスは **動的に再定義可能** であり、メタクラスを通じて構造や振る舞いを後から変更できることも多い。

例えばSmalltalk 系のOOPL、あるいはRubyでは、クラス自身も“オブジェクト”であり、動的操作の対象だ[^2][^3]。その他、JavaScriptにおけるclassもその実態は「特殊な関数」オブジェクトであるから、やはり動的操作が可能である[^4]。

[^2]: https://www.gnu.org/software/smalltalk/manual/html_node/Why-is-_0023new-there_003f_0021_003f.html 2025-12-08 19:57閲覧<br>> *The truth starts showing to their eyes about that sentence that everybody says but few people understand: “classes are objects”.'*
[^3]: https://docs.ruby-lang.org/ja/latest/class/Class.html 2025-12-08 19:59閲覧
[^4]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes 2025-12-08 20:06閲覧<br>> *'Classes are in fact "special functions", and just as you can define function expressions and function declarations, a class can be defined in two ways: a class expression or a class declaration.'*

クラスを「設計図」として例えた時、そこではクラスそれ自体の動的性質は切り捨てられて語られている。

#### 問題2. インスタンスは受動的な“製品”ではない

製品は通常、能動的に振る舞いを持たない物体である。  
しかしオブジェクト指向におけるインスタンスは **メッセージに応答し、主体として振る舞う**というのが本義である。

“製品”という比喩を用いている場面では、オブジェクトの主体性・自律性は無視されている。

#### 問題3. クラスとインスタンスは一方向の固定関係ではない

現実のオブジェクト指向では、言語にもよるが、継承・プロトタイプチェーン・ミックスイン・トレイトなど多様な構造が存在する。  
“設計図 → 製品”のような一方向・1対1の関係では説明できない。

特にRubyやSmalltalkのような「クラスもまた、（よりメタな）クラスのインスタンスである」というある種の再帰的な構造は、設計図と製品という比喩ではかえって説明が困難だ。

---

一見わかりやすい比喩ほど、本質を切除し、理解を固定化し、思考の幅を狭める危険がある。
しかし「わかりやすい」ことを上位の価値と位置づけてしまうと、こうした危険を無視ないし矮小化することを正当化可能となってしまう。

### 観点2. 説得力は、内容の正しさとは無関係に操作できる

説得力とは、内容の正しさではなく **読者が受け取る印象の強さ** である。歯に衣着せぬ言い方をするなら、「説得力を出す」とは「印象操作」そのものである。そのため、論理が粗かったり根拠が薄かったりしても、「説得力がある文章」は書けてしまう。

たとえば次の文章を考える。

```text
関数型言語では副作用は禁止されている。
なぜなら、副作用は状態を乱し、バグの原因になるからだ。
```

関数型プログラミング言語に明るくない人にとっては、説得力を持った文章として映るだろう。
しかし、実際には以下の問題がある。

#### 問題1：前提が誤っている  

関数型言語の多くは「副作用を禁止」していない。  
副作用を **分離** したり、**制御** したり、**明示** する仕組みを持ってはいるが、これらはいずれも「禁止」とは異なる。

例えばHaskellでは入出力という副作用を`IO`モナドとして分離可能にしているが、入出力という副作用の利用を「禁止」しているわけではない。

文章の“強さ”が内容の“正しさ”を保証しない典型例と言える。

#### 問題2：論理構造が曖昧でも「筋が通っているように見える」  

「Aは禁止されている。なぜならBだからだ。」  

安易に用いられがちなこの形式自体が、一見しての“確からしさ”を演出してしまう。

しかし実際には

- 「副作用を禁止している」という事実誤認  
- 「副作用は状態を乱す」という一般論  
- 「ゆえに禁止」という飛躍  

が、この一文には混在している。

それでも関数型言語に明るくない読者なら、文章のリズムだけで「なるほど」と感じやすくなってしまう。

#### 問題3：根拠の薄弱さが隠される

この文章には情報源が示されていない。誰の、あるいはどこの記述を根拠として「関数型言語では、副作用が禁止されている」という説明を作り出したのかが一切不明だ。そのため読者は「何を根拠に言っているのか」を判断できない。

説得力は、しばしば**情報源の欠如すら隠してしまう**。これを濫用すれば、「根拠は薄弱にもかかわらず、他人の心情に訴えかける説得力あるテキスト」が作成できてしまう。

---

説得力は、論理と独立した“印象操作”である以上、それに頼った説明を行ったり、それに頼った説明を鵜呑みにするのは危険であると言って良い。

### 観点3. 情報源の不透明性が隠蔽される

「◯◯とは〜〜である。X氏が提唱した。」  

この形式の文章は、あたかも一次情報をきちんと参照しているかのような印象を与える。しかし、**実際にどの文献のどの箇所を見たのか** が示されないまま、こうした文言が用いられていることは珍しくない。

ここでは、特にドメイン駆動設計（以下、DDD）文脈で頻出する「値オブジェクト」を具体例として扱う。値オブジェクトについて、以下のような説明を考えてみる。

```txt
プリミティブ型をクラスで包み、immutableにしたオブジェクトが、値オブジェクトである。
これはMartin Fowlerによって提唱された。
```

この説明も一見してもっともらしく、近しい説明すら見かけることがある。しかし出典を実際に辿っていくと、この定義には致命的な情報欠落がある他、誤解や余計な情報が付け加わっているという問題がある。

#### 問題1. 「等価性」という概念の欠落

Martin Fowlerによる著作『エンタープライズアプリケーションアーキテクチャ』（以下PoEAA）の「バリューオブジェクト」を参照してみよう。

> ID に基づいた等価性を確保していない、Money やDate Range などのシンプルな小型オブジェクト。
> (中略)
> 参照オブジェクトとバリューオブジェクトの主な相違点は、等価性の処理の方法である。(中略)バリューオブジェクトの等価性の概念はクラス内のフィールド値に基づいている。2つのDateオブジェクトで日、月、年の値が同じ場合は、等価ということになる。[^5]

[^5]: Martin Fowler(2005) p.508-509

Fowlerの説明を見るに、値オブジェクト（＝バリューオブジェクト）の特徴として記述されているのはその「等価性」という性質である。その同一性をID（識別子）によってではなく、その属性値（フィールド）によって行われるというのが、Fowlerにおける値オブジェクトの中核と言って良いだろう。
しかし、先に提示した説明例では「等価性」という性質への言及は含まれていない。結果「出典を遡らない限り、"等価性"という中心概念にはたどり着けない」という事態に陥っている。

#### 問題2. 値オブジェクトは「プリミティブ型をクラスで包む」ものか？

今度は、DDDの提唱者であるEric Evansの著書『エリック・エヴァンスのドメイン駆動設計』を参照してみる。

> あるオブジェクトが、ドメインにおける記述的な側面を表現し、概念的な同一性を持たない場合、そういうオブジェクトは、値オブジェクトと呼ばれる。
> (中略)
> 値オブジェクトは、他のオブジェクトが組み合わされてできていることもある。
> (中略)
> 値オブジェクトはエンティティを参照することもできる。[^6]

[^6]: Eric Evans(2014) p.96

エヴァンス本では、明らかに値オブジェクトの利用シーンとして「プリミティブ型をクラスで包」む以外の状況が想定されている。値オブジェクトはそれ自体複数のオブジェクトで構成されることもありうるのだから、「プリミティブ型をクラスで包む」という記述は、明確に誤りあるいは余計な制約である。
ここでは「出典を遡らない限り、本来不要な制約に縛られてしまう」という事態が生じている。

#### 問題3. 値オブジェクトは「immutableである」か？

Martin Fowlerのブログ"martinFowler.com"にも、Value Objectについての言及がある。

> To avoid aliasing bugs I follow a simple but important rule: **value objects should be immutable**. If I want to change my party date, I create a new object instead.
> (中略)
> While immutability is my favorite technique to avoid aliasing bugs, it's also possible to avoid them by ensuring assignments always make a copy. Some languages provide this ability, such as structs in C#.[^7]

[^7]: Value Object - martinFowler.com 2025-12-09 12:55 閲覧

Fowler自身も、「値オブジェクトはimmutableである*べき*だ」と述べている点から、値オブジェクトをimmutableで実装することが好ましいと考えていることはわかる。しかし、"value objects must be immutable"でなければ、"value objects is immutable"でもなく、"should"である点には注意が必要だ。immutableであることは、あくまでFowlerにとって「お気に入りの手法(my favorite technique)」であって、値オブジェクトの必要条件ではない。

immutableにするのはあくまでオブジェクトを共有する際の不具合を回避するための一つの手法であり[^8]、immutableにする以外の方法として、「常にコピーを生成する(it's also possible to avoid them by ensuring assignments always make a copy)」もはっきりと認められている。

[^8]: Value Objectについて整理しよう 2025-12-09 20:30 閲覧<br>> *一番重要なのは「値(Value)」という概念そのもの。それが複数の値の合成物からなる値ならばオブジェクトを定義してプロパティで等価比較する実装手段がいい、これをValue Objectと呼ぶ。だがオブジェクトを取り回す際には言語によっては無意識の共有操作に手を噛まれないようにせよ、回避策としてimmutableにするのもアリだよ。この順が重要である。*

値オブジェクトをimmutableにするという方法そのものは好意的に示されていることから、前2つの問題に比べて、この問題は比較的小さなものではある。しかし、それでも「immutableにする代わりに、常にコピーを用いる」という選択肢（少なくとも、それも許容されていること）が隠蔽されているという事態が発生しているという点で、やはり出典を遡って初めて発見できる問題が隠れている。

---

ここまで、例として出した「値オブジェクトの定義」にどのような問題があるかを述べてきた。しかしながら、二次情報・三次情報ではしばしば次のような縮約が起きる。

1. 一次情報の文脈を削り、「値オブジェクトは immutable にすべき」という一文だけが切り出される  
2. さらにそれが、「プリミティブを包んだ immutable クラス」という**実装スタイルの一案**と結びつく  
3. やがて、「値オブジェクト＝プリミティブラッパ＋ immutable」が“定義”として扱われるようになる

この過程で、「等価性を値によって判断する」「オブジェクトも含めた複合体として構成可能である」「共有時の問題を回避するためのimmutable」といった本来の情報は失われてしまう。

その結果、次のような現象が起きる。

- ドメイン内のあらゆる整数や文字列を、専用クラスで機械的に包むだけの「値オブジェクト大量生産」が始まる  
- それを「原典がそう言っているから」という形で正当化しようとする  
- しかし、どのページのどの記述を根拠にしているのかは示されない  

ここでは、**「誰かの解釈」が「原典の主張」として権威化される** という事態が生じている。
しかし、一次情報へ辿るための手がかり（書名、ページ数）が提示されないため、読者はその解釈が妥当かどうかを自力で検証しにくい。

本来であれば、「どの資料の」「どこの箇所の」「どの記述を」どのように読んで「値オブジェクト」を理解したのかを、最低限でも示すべきである。  それを省略したまま「◯◯とは〜〜であり、X氏がそう言っている」とだけ書くことは、**情報源の不透明性で読者を騙す構図**になりうる。
情報源が曖昧な説明は、「理解した“つもり”」だけを量産し、  読者から「自分で確かめる手段」と「疑う権利」を奪ってしまう。

### まとめ：なぜ「わかりやすさ」「説得力」が害を生むのか

比喩は情報を丸めて滑らかにするに一方で、多くの情報を暗黙的に削り捨ててしまう。
説得力は、その一見した尤もらしさによって、論理の脆弱さや根拠の薄弱さを覆い隠してしまう。
引用の欠落によって、誰かの解釈が権威を伴って広まり、しかしその原典へのアクセスは困難という事態が生じる。

**結果として、「理解した気分」だけが加速し、「実際の理解」は置き去りになる。**

わかりやすさは善にも悪にもなる。  
問題は、その裏にある不透明性だ。

## 「透明性の倫理」とは何か

本稿で「透明性の倫理」と呼ぶのは、端的に言えば次の態度である。

> **自分の限界と、自分の範囲を明示せよ。**

この一文は、以下の三つに分解できる。

1. 限界の開示
2. 範囲の開示（事実と解釈の分離）
3. 権威と主張の切断

以降では、この三つを順に見ていく。

### 1. 限界の開示

- どこまで遡れたか  
- どこで理解が途切れたか  
- どこから先が推測なのか  

理解が不十分であっても、それを明示すれば害は小さくなる。  
「どこまで調べたか」を公開すること自体が、読者への誠実な情報提供となる。

### 2. 範囲の開示（事実と解釈の分離）

資料の内容と、自分の解釈・主張を混ぜないこと。  
混ざると、資料の権威を借りて自分の立場を正当化する構造が生まれる。

引用表記や段落構成などを用いて、  
**「何が事実で、何が自分の思考か」**  
を読者に見える形で分離する必要がある。

### 3. 権威と主張の切断

一次資料の記述は「事実の提示」であり、筆者の主張を必然的に裏付けるわけではない。  
引用した瞬間に自説が強化されるわけではない。  
自分の主張は、自分の論として独立させなければならない。

## 「透明性の倫理」実践例：「単一責任原則」について

## 結び：透明性は、書き手と読み手の自由を守る

透明性の倫理は、書き手を縛るための規律ではない。  
むしろ、断言圧力や完璧主義から書き手を解放する枠組みである。

- 「ここまではわかっている」  
- 「ここから先は推測だ」  
- 「この部分は一次資料をまだ追えていない」

そう書いてよい。  
そう書くことで、読者はどこを信じ、どこを疑い、どこを自分で調べるべきか判断できる。

わかりやすさも説得力も、それ自体が悪ではない。  
しかし、透明性を欠いた説明は、たとえ滑らかであっても理解の役に立たない。

**理解とは、境界線と限界が明示された場所にこそ生まれる。**

## 参考資料

- "Go To Statement Considered Harmful"
  - <https://dl.acm.org/doi/10.1145/362929.362947> 2025-12-08 15:15閲覧
- GNU Smalltalk User’s Guide
  - <https://www.gnu.org/software/smalltalk/manual/html_node/Why-is-_0023new-there_003f_0021_003f.html>
- Ruby3.4 リファレンスマニュアル
  - <https://docs.ruby-lang.org/ja/latest/class/Class.html>
- MDN
  - <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes>
- Eric Evans(2011)『エリック・エヴァンスのドメイン駆動設計』翔泳社 今関剛 監訳, 和智右桂・牧野祐子 訳
- Martin Fowler(2005)『エンタープライズアプリケーションアーキテクチャ』翔泳社　長瀬嘉秀 監訳, 株式会社テクノロジックアート 訳
- Value Object - martinFowler.com
  - <https://martinfowler.com/bliki/ValueObject.html>
- Value Objectについて整理しよう
  - <https://kumagi.hatenablog.com/entry/value-object>
- 値オブジェクトへの誤解が生まれる一つのストーリー - 文脈と定義を大事にする
  - <https://zenn.dev/339/articles/554d9f1e8cc645>
