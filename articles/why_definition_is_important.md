---
title: "なぜソフトウェア開発では『定義』が問題解決に直結するのか"
emoji: "🤔"
type: "idea" # tech: 技術記事 / idea: アイデア
published: true
---

ソフトウェア開発の文脈で、「専門用語の定義を追うのは無意味だ」という主張を見聞きした。
本稿では、この主張は日常語に対するものではなく、「設計原則や開発手法といった、共有知として流通している概念」に向けられたものとして扱う。
その上で、上記に対する所感をここで記しておく。

---

TDD、OOP、その他設計原則――そうした言葉の定義を詰めるより、目の前の問題解決に集中すべきだ、というのが件の主張だ。

一見すると実務的で、現場感覚に根ざした意見に思える。  
しかし私は、この主張は**問題解決を重視するという態度そのものと、実は両立していない**と考えている。

## 本稿の射程

本稿で批判の対象とするのは、日常語一般に対する意味の曖昧さではない。また、実務上の制約から定義確認を省略する判断そのものでもない。

本稿が扱うのは以下の条件を**すべて**満たす言説である。

1. TDDやOOP、設計原則といった共有知として流通している専門概念が対象とする
2. その由来・原典・定義を確認する行為そのものを無意味あるいは有害とみなす
3. かつその結果生じる概念のズレや評価の歪みを問題視しない立場

1.を満たさないのであれば、それは日常の会話である。本稿は、日常会話における言葉を制限・規定する意図を持たない。
2.を満たさないのであれば、それは本稿とは対立しない、むしろ立場を同じくするものである。
3.を満たさない場合、さらに2.を満たすのであれば、ズレや評価の歪みを「問題」と呼ぶための参照点を否定したまま、それを問題視することになり、論理的に自己矛盾を含む。

なお本稿では、ある用語が原典や参照している定義と対応付けられない、あるいは異なる定義体系のまま同一名称で用いられている状態を問題にしている。
これは実践上の是非や価値判断を直接に意味するものではない。

## 問題解決は、言葉を通してしか行えない

ソフトウェア開発は個人競技ではない。

問題を定義し、解決策を議論し、設計意図を共有し、コードをレビューする。  
これらはすべて、言葉による行為である。

問題と技術は両輪であるが、その両輪を接続しているのは自然言語だ。言葉の意味が人によってズレていれば、

- 同じ問題を話しているつもりで、実は別の話をしている  
- 合意したと思った設計が、各自で異なる意味を持つ  
- 技術が「役に立たなかった」という誤った評価が生まれる  

といった事態が起きる。

専門用語の定義を追うとは、  **こうした解釈ズレを早期に検知するための作業**にほかならない。

## 定義を追わないことでの弊害：実例と共に

### TDDの混乱：必要条件と十分条件

TDDを例に取ろう。TDDは、Kent Beckみずからその誤解を解こうと試みなければならなかったほど[^1]に、解釈ズレが深刻な時期があった。

[^1]: Kent Beck(2023), 和田卓人(2024)

和田卓人(2024)によれば、例えば以下のようなものを指して「テスト駆動開発」と呼ばれているケースがあるという。

- （Jestやpytestのようなテスティングフレームワークを使って）テストコードを書くこと
- 開発者が自分でテストコードを書くこと
- テストコードを実装よりも前に書くこと 

しかしこれらは、テスト駆動開発の必要条件の一部に該当するものの、原典で示されている定義を満たすには不十分であり、原典の定義とは一致しない用法として用いられている例である[^2]。

[^2]: 和田卓人(2024)<br/>> これらはテスト駆動開発の必要条件ではありますが、十分条件ではありません。今回のKent Beckの意見を尊重するならば、これらを「テスト駆動開発」と呼ぶのは誤りであるということになります。

TDD（Test-Driven Development）は、Red–Green–Refactor という短いサイクルを通じて、**テストを設計改善のためのフィードバック装置として使う開発手法**であり、このフィードバックループこそが核心である[^3]。単なる作業順序の話ではない。

[^3]: 和田卓人(2022) p.73<br/>> TDDは次のような「レッド・グリーン・リファクタリング」のサイクルで開発します。<br/>・やるべきことをざっと整理し、箇条書きのTODOリストのような形で書き出しておく<br/>・レッド：TODOリストから「1つ」ピックアップして、テストから書き（テストファースト）、そのテストを実行して失敗させる<br/>・グリーン：失敗しているテストを成功させることに集中した実装を行う<br/>・リファクタリング：すべてのテストが成功しているままで実装コードやテストコードをきれいに整理整頓する<br/>・リファクタリングが終わったら気づきをTODO リストに反映し、次のTODO 項目を選んでレッドに進む<br/>　上記のように、レッド、グリーン、リファクタリング、レッド、グリーン、リファクタリング、……と繰り返していくのがTDDの姿です。

このズレを放置すると、

- 「テストは書いているのに設計が良くならない」  
- 「TDDは冗長で遅い」  

といった評価が生まれる。

だがそれは、原典で定義されているTDDそのものへの評価ではなく、定義の一部のみを取り出した用法、あるいは異なる実践を同一名称で呼んだものへの評価である。

この混乱の主要因の一つは、定義や出典の不確認である。

### 「オブジェクト指向プログラミング」は一つではない：定義と歴史の軽視

「オブジェクト指向プログラミング（以下、OOP）」も同様である。

「OOP」という言葉を見出したアラン・ケイが想定していたのは前者であり、そこで核心として捉えられていたのはまさに「messaging」である[^4]。

[^4]: Alan Kay(1998)<br/>> The big idea is "messaging" - that is what the kernal of Smalltalk/Squeak is all about (and it's something that was never quite completed in our Xerox PARC phase). The Japanese have a small word - ma - for "that which is in between" - perhaps the nearest English equivalent is "interstitial".

一方、後者の「OOP」はビャーネ・ストロヴストルップによるC++を起点とした系譜であり、そこで注目されているのは「messaging」ではなく「データ抽象化」であった[^5]。ストロヴストルップ自身も、言語開発の時点でSmalltalkからの思想的影響はあまり受けていないことを明言している[^6]。

少なくともこれらの記述から私が解釈する限り、これら2つのOOPは、少なくとも、同一の思想・文脈として連続的に語れるものではない。

- Smalltalk系の「メッセージング中心のOOP」  
- C++系の「クラス・静的型中心のOOP」

このように、明確に異なる思想的系譜にあるものとして、それぞれを配置するのが妥当だ。

[^5]: Bjarne Stroustroup(2005) p.131<br/>> オブジェクト指向プログラミングは継承を使うプログラミングだ。データ抽象化はユーザ定義タイプを使うプログラミングだ。ほとんど例外なく、オブジェクト指向プログラミングはデータ抽象化のスーパーセットだ。
[^6]: Bjarne Stroustroup(2005) p.53<br/>> しかし1985年にリリースされたC++に明瞭な痕跡を残しているのは、C、Simula、Algol68、そしてある一点でBCPLのみである。

こうした歴史的経緯を無視したまま、例えば「OOPとは変更容易性を高めるための手段だ」とだけ語ると、「どのOOPの話か」が消失する。あるいは、どちらのOOPについての注釈無く「OOPとは何か」とだけ語ろうとすると、これら両者の文脈が混在し、定義不能に陥る。

結果として、

- OOPの何が本質なのか  
- どの文脈で何が有効なのか  

という議論が成立しなくなる。

これは定義の問題であると同時に、**歴史的背景を軽視したことによる混乱**でもある。

### 単一責任原則の混乱：「責任」という言葉の暴走

単一責任原則（SRP）も、言葉が一人歩きした例だ。
原典で述べられている定義は、次の一文に尽きる。

> In the context of the SRP, we define a responsibility to be ‘a reason for change’.[^7]

[^7]: Martin(2003) p.97

ここで問題にされているのは「責務の数」ではない。**変更理由の集合**である。しかし出典が忘れられた瞬間、「責任」という日常語が暴走し、

- 責任が多そうならば分割せよ
- なんとなく複雑ならば分割せよ

といった曖昧な道徳論へと変質する。

これも、定義を遡らなかったことによる概念劣化の一例である。

---

ここまで、TDD・OOP・SRPという、定義が参照・確認されなかったが故にその用法に混乱が生じた例を見てきた。

定義の参照・確認を怠ったときに発生する問題は、混乱だけにとどまらない。TDDでも軽く触れたが、時としてその概念そのものがすりかわったままに、低く評価されてしまう場合がある。

- TDDと言いつつ、テストを先に書いただけでその後の設計改善に活用しないことで、「ただテストを書くのと変わらない」と評価されてしまう
- OOPの系譜を無視して「オブジェクト指向プログラミング」という単一概念にまとめようとして、「中核になる思想が無い」と評価されてしまう
- SRPを日常語で理解しようとして、その意味内容が爆発・曖昧化して、「事実上何も言っていない原則」と評価されてしまう

既に存在している概念を批評し、時にはネガティブな評価を下す事自体は、なんら問題ではない。
だが、本来の定義に従わない「TDD/OOP/SRPのような何か」が広まってしまい、それらを根拠としてTDD/OOP/SRPに対して下されたネガティブな評価は、原典で定義された概念に対する適切な評価とは言えない。

それら概念が正しく批評され、正しく肯定され、時には正しく批判されるためにも、その定義を追うことは重要なことである。

## なぜ「定義を追わない」ことのコストは見えにくいのか

定義を追わなかったことで生じるコストは、多くの場合、即座には可視化されない。

- 会話が少し噛み合わない
- 設計レビューで違和感が残る
- 「なんとなく」議論が長引く

こうした違和感は、個々の場面では小さく、「まあいいか」「現場あるある」として処理されがちだ。
しかし実際には、これらの多くは**言葉の意味が揃っていないことによる摩擦**である。

定義を追わないことのコストは、

- バグのように一箇所で顕在化しない
- 技術的負債のように徐々に蓄積する
- 後から原因を特定しにくい

という性質を持つ。

そのため「定義を追うのは無意味だ」という主張は、短期的には実務的に見え、長期的なコストを不可視化したまま通用してしまう。
これは、問題が存在しないのではなく、**問題の形で現れていないだけ**である。

## 実務において「定義を追う」とはどういうことか

ここまで読んで、「常に原典を読めと言っているのか」と感じたなら、それは行き過ぎた理解だ。
原典を参照しようとすることは好ましい態度であるし、理想的ではあるが、あくまで理想に留まる。

実務において「定義を追う」とは、例えば次の程度の行為を想定している。

- その言葉が、誰の・どの文脈の定義かを意識する
- 議論が噛み合わないとき、「定義のズレ」を疑う
- 「自分はこの意味で使っている」と明示する
- 由来不明なら、「由来不明」であることを自覚・開示した上で用いる

重要なのは、定義を暗黙のまま放置しないことだ。

定義は信奉する対象ではない。**参照し、ずらし、応用し、時には捨てるための基準**である。

基準を持たずに応用だけを語ることはできない。

## 想定される反論と再反論

### 「大体わかっていればいい」という態度について

具体的には、以下のような主張を想定している。

> 厳密な定義は不要だ。  
> 大体わかっていれば実務は回る。

しかしこの主張は、「定義を追うのは無意味だ」という主張から、すでに一歩後退している。

なぜなら、「大体わかっているかどうか」を判断するためにも参照されるべき定義や基準が暗黙に想定されているからである。
「大体わかっている」という言明は、定義不要論ではなく、**定義の存在を前提にした省略表現**にすぎない。

問題は、その省略がどこまで許容されるかを判断する材料が、共有されていない点にある。

定義を明示的に追わない限り、「大体」の範囲は人ごとに異なり、再び解釈ズレが持ち込まれる。

### 「定義に従うのが、本当に正しいのか。現場によって異なる正しさがある」という反論について

ここで注意したいのは、「正しい」という言葉の多義性だ。

- 定義が妥当であること  
- その定義に従って実践すること  

この二つは、論理的に別の問題である。

「TDDの定義は、正しくはこうだ」と主張しつつ、「このプロジェクトにおいて、TDDは良い手法ではない」と主張することは全くの無矛盾だ。

実践における「正しさ」は、前提や制約条件によって変わりうる。その意味で、実践における「正しさ」は多様であって良い。
しかしそのことは、**定義の「正しさ」も多様であって良いということを含意しない**。

この混同があると、「定義に従うのが「正しい」のか？」という問いが、詭弁として機能し始める。

定義に従うべきは「Aとは何か？」という認識・理解のレイヤにおいてである。このレイヤにおいては本来の定義こそ「正しい」し、またそこでのバラツキやズレは可能な限り解消されるべきだ。
一方、実践における「正しさ」は「Aとは何か？」という定義の内容と、それが実際におかれば前提・文脈との兼ね合いで、ようやく実践レイヤにおける「正しさ」が決定する。つまり、実践のレイヤにおける「正しさ」とは、「Aとは何か？」と前提・文脈の複合体なのである。

「正しい」という言葉に惑わされてはならない。定義について語る時と、定義を用いる時とでレイヤが異なるのであり、それぞれで語られる「正しい」の意味内容は明確に異なっているのだ。

### 「定義を重視すると、後続する人々の創造性や工夫を奪うのではないか？」という反論について

具体的な想定としては、次のような反論である。

> 定義を厳密に扱いすぎると、現場や後続する人々の創造性・工夫の余地を狭めてしまうのではないか。

過去の定義や用語法が硬直化し、新しい発想を阻害してしまうというこの懸念自体は、理解できる。

しかし、この反論には重要な取り違えがある。

**既存の定義を正確に理解することと、その定義の枠内に思考や実践を閉じ込めることは、別の行為である。**

本稿で主張しているのは後者ではなく、前者に留まる。

定義を追うという行為は、既に存在する概念が、どのような問題意識から生まれ、どの範囲までを指していたのかを把握するためのものである。

それは、創造性を抑圧するための檻ではなく、**どこからが「既存」で、どこからが「新規」なのかを判別するための基準**だ。

むしろ、定義を曖昧なままにした状態こそが、後続する人々の創造性を奪う。
なぜならその場合、以下のような事態が起きるからである。

- 何が既に試され、語られてきたのかが分からない  
- どこからが本当に新しい工夫なのかが判別できない  
- 過去の議論や失敗を、知らずに再演する  

改めて書くが、**新しい意味を作ることと、既存の意味を曖昧に流用することは、全く別の行為だ**。前者は創造であり、後者は混乱である。

定義を追うことは、創造性を縛る行為ではない。**創造と、再解釈と、原典の定義と一致しない用法とを、区別可能にするための前提条件**である。

後続する人々が本当に自由に工夫し、発明できるようにするためにも、「何がどこまで既存の概念なのか」を明確にしておく必要がある。

## DDDとの衝突

DDD（Domain-Driven Design）は近年広く受け入れられている手法・理論だが、この観点からも「定義を追う」ことについて考えてみる。
端的に言えば、「定義を追うのは重要ではない」という考え方は、DDDの思想と正面から衝突する。

ユビキタス言語は、DDDにおける中核概念の一つである。

> モデルを言語の骨格として使用すること。チーム内のすべてのコミュニケーションとコードにおいて、その言語を厳格に用いることを、チームに約束させること。
> 図やドキュメント、そして何より会話の中では同一の言語を使用すること。[^8]

[^8]: Eric Evans(2011) p.26

これは、**定義を合意し、維持する行為**そのものだ。

定義を軽視する立場は、以下を同時に否定していることになる。

- ユビキタス言語の構築  
- モデルと会話の一致  

DDDにおいて、ユビキタス言語は変化するものであり、その変化のためにチームが注意を払うことを要求する。
その意味で、ユビキタス言語として定義される語群は、必ずしも固定的ではなく、むしろ流動的な性質も持つ[^9]。

[^9]: Eric Evans(2011) p.26-27<br/>> ユビキタス言語における変更は、モデルに対する変更であると認識すること。<br/>ドメインエキスパートは、ドメインについての理解を伝えるには使いにくかったり不適切だったりする用語や構造に異議を唱えるべきであり、開発者は、設計を妨害することになるあいまいさや不整合に目を光らせるべきである。

しかしこれは、あくまで「全体的な時系列としては流動的である」という意味であり、「常に流動的であってよい、その時々で固定された定義が存在しなくても構わない」というところまでは含意しないと、私は解釈する。
全体としては変化していったとしても、その時々の会話・ドキュメント・実装においては、固定化された定義が無くては結局は混乱に陥り、「ユビキタス言語」というものが存在しない状況となんら変わりないからだ。

「定義は重要ではない」という立場を取る限り、それは少なくとも、ユビキタス言語を中核に据えるDDDの立場とは相容れない。

## まとめ：定義を追うことは、信仰ではない

専門用語の定義を追うことは、以下を**含意しない**。

- 権威に従うこと  
- 教条主義  
- 思考停止  

それは、どの文脈の話をしているのかを特定し、解釈ズレを早期に検知し、批判と改善を可能にするための、**知的なデバッグ作業**である。

問題解決を本気でやるなら、言葉から逃げることはできない。

「定義を追うのは無意味だ」と言うのは自由だ。  
だがその瞬間、「同じ問題について話している」という前提そのものを、自分から手放していることには自覚的であるべきだ。

定義を把握し、その上に知を積み重ねるという手順は、知識が混乱なく累積可能であるために果たされるべき条件である。

## 参考資料

- Kent Beck. (2023-12-11). Canon TDD. <https://tidyfirst.substack.com/p/canon-tdd> 2025-12-17閲覧
- 和田卓人(2024-03-08). 【翻訳】テスト駆動開発の定義. <https://t-wada.hatenablog.jp/entry/canon-tdd-by-kent-beck> 2025-12-17閲覧
- 和田卓人(2022). 『自動テストとテスト駆動 開発、その全体像』 Software Design, 2022年(3月号), p66~
- Alan Kay(1998-10-10). Alan Kay On Messaging. <https://wiki.c2.com/?AlanKayOnMessaging> 2025-12-17閲覧
- Bjane Stroustrup(2005) 『C++の設計と進化』(ソフトバンク パブリッシング) 岩谷宏 訳
- Robert C. Martin（2003）『Agile Software Development, Principles, Patterns, and Practices』(Pearson Education)
- Eric Evans（2011）『エリック・エヴァンスのドメイン駆動設計』（翔泳社）今関剛 監訳, 和智右桂・牧野祐子 訳
